#include "STModelReaderTask.hh"

// FAIRROOT classes
#include "FairRootManager.h"
#include "FairRunOnline.h"
#include "FairRun.h"
#include "FairRunAna.h"
#include "FairRuntimeDb.h"

#include <glob.h>
#include "TXMLAttr.h"

ClassImp(STModelReaderTask);

STModelReaderTask::STModelReaderTask(TString filename)
{
  fLogger = FairLogger::GetLogger(); 

  fData = new TClonesArray("STData");
  fProb = new TClonesArray("STVectorF");
  fEff = new TClonesArray("STVectorF");
  fCMVector = new TClonesArray("STVectorVec3");
  fLabRapidity = new TClonesArray("STVectorF");
  fBeamRapidity = new STVectorF();
  fFragVelocity = new TClonesArray("STVectorVec3");
  fFragRapidity = new TClonesArray("STVectorF");

  auto fInputPath = TString::Format("%s/input/", gSystem->Getenv("VMCWORKDIR"));
  if(filename.BeginsWith("imqmd") || filename.BeginsWith("approx"))  
  { fReader = std::unique_ptr<STImQMDReader>(new STImQMDReader(fInputPath + filename)); }
  else if (filename.BeginsWith("imqmdNew")) { fReader = std::unique_ptr<STImQMDReader>(new STImQMDReader(fInputPath + filename)); }
  else if(filename.BeginsWith("pbuu")) { fReader = std::unique_ptr<STpBUUReader>(new STpBUUReader(fInputPath + filename)); }
  else
    LOG(FATAL)<<"STModelReader cannot accept event files without specifying generator names."<<FairLogger::endl;
}

STModelReaderTask::~STModelReaderTask()
{}

int STModelReaderTask::GetNEntries()
{ return fReader -> GetEntries(); }

InitStatus STModelReaderTask::Init()
{
  FairRootManager *ioMan = FairRootManager::Instance();
  if (ioMan == 0) {
    fLogger -> Error(MESSAGE_ORIGIN, "Cannot find RootManager!");
    return kERROR;
  }
  
  double E = fBeamA*(fEnergyPerA + 931.8);
  double PMag = std::sqrt(E*E - fBeamA*fBeamA*931.8*931.8);
  TLorentzVector beamVect(0, 0, PMag, E);
  fBeamRapidity -> fElements.resize(2);
  fBeamRapidity -> fElements[1] = beamVect.Rapidity();
  beamVect.Boost(-fBoostVector);
  fBeamRapidity -> fElements[0] = beamVect.Rapidity();

  new((*fData)[0]) STData();
  for(int i = 0; i < fSupportedPDG.size(); ++i)
  {
    new((*fProb)[i]) STVectorF();
    new((*fEff)[i]) STVectorF();
    new((*fCMVector)[i]) STVectorVec3();
    new((*fLabRapidity)[i]) STVectorF();
    new((*fFragVelocity)[i]) STVectorVec3();
    new((*fFragRapidity)[i]) STVectorF();
  }

  ioMan -> Register("STData", "ST", fData, fIsPersistence);
  ioMan -> Register("Prob", "ST", fProb, fIsPersistence);
  ioMan -> Register("Eff", "ST", fEff, fIsPersistence);
  ioMan -> Register("CMVector", "ST", fCMVector, fIsPersistence);
  ioMan -> Register("LabRapidity", "ST", fLabRapidity, fIsPersistence);
  ioMan -> Register("BeamRapidity", "ST", fBeamRapidity, fIsPersistence);
  ioMan -> Register("FragVelocity", "ST", fFragVelocity, fIsPersistence);
  ioMan -> Register("FragRapidity", "ST", fFragRapidity, fIsPersistence);

  return kSUCCESS;
}

void
STModelReaderTask::SetParContainers()
{
  FairRunAna *run = FairRunAna::Instance();
  if (!run)
    fLogger -> Fatal(MESSAGE_ORIGIN, "No analysis run!");

  FairRuntimeDb *db = run -> GetRuntimeDb();
  if (!db)
    fLogger -> Fatal(MESSAGE_ORIGIN, "No runtime database!");

  fPar = (STDigiPar *) db -> getContainer("STDigiPar");
  if (!fPar)
    fLogger -> Fatal(MESSAGE_ORIGIN, "Cannot find STDigiPar!");
}

void STModelReaderTask::Exec(Option_t *opt)
{
  std::vector<STTransportParticle> particleList;
  if(fReader -> GetNext(particleList))
  {
    fLogger -> Info(MESSAGE_ORIGIN, TString::Format("Event %d", fReader -> GetEntry()));
    auto data = static_cast<STData*>(fData -> At(0));
    data -> ResetDefaultWithLength(particleList.size());
    data -> beamEnergy = fEnergyPerA;
    for(int i = 0; i < data -> multiplicity; ++i) data -> vaMom[i].SetXYZ(0,0,5000);

    for(int i = 0; i < fSupportedPDG.size(); ++i)
    {
      auto& prob = static_cast<STVectorF*>(fProb -> At(i)) -> fElements;
      prob.clear();
      auto& eff = static_cast<STVectorF*>(fEff -> At(i)) -> fElements;
      eff.clear();
      auto& cmVector = static_cast<STVectorVec3*>(fCMVector -> At(i)) -> fElements;
      cmVector.clear();
      auto& labRapidity = static_cast<STVectorF*>(fLabRapidity -> At(i)) -> fElements;
      labRapidity.clear();
      auto& fragVelocity = static_cast<STVectorVec3*>(fFragVelocity -> At(i)) -> fElements;
      fragVelocity.clear();
      auto& fragRapidity = static_cast<STVectorF*>(fFragRapidity -> At(i)) -> fElements;
      fragRapidity.clear();


      for(const auto& particle : particleList)
      {
        if(fSupportedPDG[i] == particle.pdg)
        {
          auto p_info = TDatabasePDG::Instance() -> GetParticle(particle.pdg);
          TLorentzVector fragment;
          TVector3 vect(particle.px, particle.py, particle.pz);
          fragment.SetVectM(vect, p_info -> Mass());
       
          prob.push_back(1);
          eff.push_back(1);
          cmVector.push_back(vect*1000);
          fragRapidity.push_back(fragment.Rapidity());
          fragVelocity.push_back(fragment.BoostVector());
          fragment.Boost(fBoostVector);
          labRapidity.push_back(fragment.Rapidity());
        }else
        {
          prob.push_back(0);
          eff.push_back(0);
          cmVector.emplace_back(0, 0, 0);
          fragRapidity.push_back(0);
          fragVelocity.emplace_back(0,0,0);
          labRapidity.push_back(0);
        }
      }
    }
  }else fLogger -> Fatal(MESSAGE_ORIGIN, "Event ID exceeds the length of the TChain");
}

void STModelReaderTask::SetPersistence(Bool_t value)                                              
{ fIsPersistence = value; }
void STModelReaderTask::SetEventID(int eventID)
{ fReader -> SetEntry(eventID); }
void STModelReaderTask::SetBeamAndTarget(int beamA, int targetA, double energyPerA)
{ 
  fTargetA = targetA; 
  fBeamA = beamA; 
  fEnergyPerA = energyPerA;

  double E = energyPerA*beamA + beamA*931.5;
  double pMag = std::sqrt(E*E - beamA*beamA*931.5*931.5);
  fFourVect.SetPxPyPzE(0, 0, pMag, E + targetA*931.5);
  fBoostVector = fFourVect.BoostVector();
}

